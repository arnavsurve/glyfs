---
title: Streaming API
description: Real-time streaming responses from your AI agents using Server-Sent Events
---

import { Callout } from 'fumadocs-ui/components/callout';

# Streaming API

The Streaming API provides real-time streaming responses from your AI agents using Server-Sent Events (SSE). Get immediate feedback as the agent generates its response, perfect for interactive applications.

## Endpoint

```
POST /api/agents/{agentId}/invoke/stream
```

## Authentication

Include your API key in the Authorization header using Bearer authentication:

```http
Authorization: Bearer apk_your_api_key_here
```

<Callout type="info">
**Agent-Specific Keys** - Each API key only works with the specific agent it was created for. See [Authentication](/docs/authentication) for complete details.
</Callout>

## Request Format

### Headers
- `Content-Type: application/json`
- `Authorization: Bearer {your_api_key}`

### Body

```json
{
  "message": "Your question or prompt here",
  "history": [
    {
      "role": "user",
      "content": "Previous user message"
    },
    {
      "role": "assistant", 
      "content": "Previous assistant response"
    }
  ]
}
```

<Callout type="info">
**Identical Request Format** - The request format is identical to the [Invoke API](/docs/api/invoke). Only the response format differs.
</Callout>

## Response Format

The response is a stream of Server-Sent Events (SSE). Each event is a JSON object with the following structure:

```json
{
  "type": "event_type",
  "content": "event_content",
  "data": { /* additional data */ }
}
```

## Event Types

### `metadata`
Initial event with agent information.

```json
{
  "type": "metadata",
  "content": "",
  "data": {
    "agent_id": "7dcf770a-066a-47c7-85ab-731495f99b76"
  }
}
```

### `token`
Individual text chunks as the response is generated.

```json
{
  "type": "token",
  "content": "Hello",
  "data": null
}
```

### `tool_event`
Tool execution events when the agent uses tools. The actual structure depends on the specific tool being used and MCP server implementation.

```json
{
  "type": "tool_event",
  "content": "",
  "data": {
    "tool_name": "example_tool",
    "status": "executing",
    "result": "...",
    "error": null
  }
}
```

<Callout type="note">
**Tool Event Variability** - Tool event structure varies based on the MCP server and tool implementation. See [Tools & MCP](/docs/tools/) documentation for specific tool event formats.
</Callout>

### `done`
Final event indicating completion with usage statistics.

```json
{
  "type": "done",
  "content": "",
  "data": {
    "response": "Complete response text",
    "usage": {
      "prompt_tokens": 50,
      "completion_tokens": 25,
      "total_tokens": 75
    }
  }
}
```

### `error`
Error event if something goes wrong during generation.

```json
{
  "type": "error",
  "content": "Error description",
  "data": null
}
```

## Examples

### JavaScript/Node.js

```javascript
const response = await fetch('https://glyfs.dev/api/agents/your-agent-id/invoke/stream', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer apk_your_api_key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    message: 'Tell me a story about a robot'
  })
});

const reader = response.body.getReader();
const decoder = new TextDecoder();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  const chunk = decoder.decode(value);
  const lines = chunk.split('\n');
  
  for (const line of lines) {
    if (line.startsWith('data: ')) {
      try {
        const eventData = JSON.parse(line.substring(6));
        
        switch (eventData.type) {
          case 'metadata':
            console.log('Agent ID:', eventData.data.agent_id);
            break;
          case 'token':
            process.stdout.write(eventData.content);
            break;
          case 'tool_event':
            console.log('Tool event:', eventData.data);
            break;
          case 'done':
            console.log('\nResponse complete:', eventData.data.response);
            console.log('Usage:', eventData.data.usage);
            break;
          case 'error':
            console.error('Error:', eventData.content);
            break;
        }
      } catch (e) {
        console.error('Failed to parse event:', e);
      }
    }
  }
}
```

### Python

```python
import requests
import json

response = requests.post(
    'https://glyfs.dev/api/agents/your-agent-id/invoke/stream',
    headers={
        'Authorization': 'Bearer apk_your_api_key',
        'Content-Type': 'application/json'
    },
    json={
        'message': 'Tell me a story about a robot'
    },
    stream=True
)

for line in response.iter_lines():
    if line:
        line_str = line.decode('utf-8')
        if line_str.startswith('data: '):
            try:
                event_data = json.loads(line_str[6:])
                
                if event_data['type'] == 'token':
                    print(event_data['content'], end='', flush=True)
                elif event_data['type'] == 'done':
                    print(f"\nComplete response: {event_data['data']['response']}")
                    print(f"Usage: {event_data['data']['usage']}")
                elif event_data['type'] == 'error':
                    print(f"Error: {event_data['content']}")
            except json.JSONDecodeError as e:
                print(f"Failed to parse event: {e}")
```

### cURL

```bash
curl -N "https://glyfs.dev/api/agents/your-agent-id/invoke/stream" \
  -H "Authorization: Bearer apk_your_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Count to 5 slowly"
  }'
```

### Example Output

```
data: {"type":"metadata","content":"","data":{"agent_id":"7dcf770a-066a-47c7-85ab-731495f99b76"}}

data: {"type":"token","content":"O","data":null}

data: {"type":"token","content":"n","data":null}

data: {"type":"token","content":"e","data":null}

data: {"type":"token","content":"…","data":null}

data: {"type":"done","content":"","data":{"response":"One… Two… Three… Four… Five.","usage":{"prompt_tokens":5,"completion_tokens":12,"total_tokens":17}}}
```

## Error Handling

### Network Errors
```javascript
// Handle connection drops gracefully
const handleStream = async () => {
  try {
    await processStream();
  } catch (error) {
    if (error.name === 'AbortError') {
      // Connection was cancelled
      console.log('Stream cancelled by user');
    } else {
      // Network error - implement retry logic
      console.error('Network error:', error);
      setTimeout(handleStream, 1000); // Retry after 1 second
    }
  }
};
```

### Parsing Errors
```javascript
// Always wrap JSON parsing in try-catch
const parseEvent = (line) => {
  try {
    return JSON.parse(line.substring(6));
  } catch (e) {
    console.warn('Malformed event data:', line);
    return null;
  }
};
```

### Authentication Errors

Same error responses as the Invoke API. Common status codes:

| Status | Error Message | Cause |
|--------|---------------|-------|
| `401` | `missing authorization header` | No Authorization header provided |
| `401` | `invalid authorization header format` | Header doesn't start with "Bearer " |
| `401` | `invalid API key format` | API key doesn't start with "apk_" |
| `401` | `invalid API key` | API key not found or inactive |
| `404` | `agent not found` | Agent doesn't exist or not accessible |

## Best Practices

### Stream Handling
1. **Buffer Management**: Handle partial events and buffer incomplete JSON data
2. **Reconnection**: Implement automatic reconnection for dropped connections
3. **Resource Cleanup**: Always close streams and clean up resources properly
4. **Timeout Handling**: Set appropriate timeouts for long-running streams

### UI/UX
1. **Incremental Updates**: Update your UI as tokens arrive for better responsiveness
2. **Progress Indicators**: Show generation progress to keep users engaged
3. **Error Recovery**: Gracefully handle and display errors to users
4. **Cancellation**: Allow users to cancel long-running streams

### Performance
1. **Throttling**: Throttle UI updates if tokens arrive very rapidly
2. **Memory Management**: Clear old tokens/responses to prevent memory leaks
3. **Event Filtering**: Only process events your application needs

### Tool Integration
1. **Tool Feedback**: Display tool execution progress to users
2. **Error Visualization**: Show tool errors in a user-friendly way
3. **Status Updates**: Keep users informed of tool execution stages

## Use Cases

The Streaming API is ideal for:

- **Interactive Chat**: Real-time conversational interfaces
- **Live Content Generation**: Streaming blog posts, articles, code
- **Progress Feedback**: Showing generation progress during long operations
- **Tool Visualization**: Displaying tool execution and results in real-time
- **Responsive UX**: Keeping users engaged during lengthy responses
- **Collaborative Editing**: Real-time collaborative writing or editing

For simple request/response scenarios, consider the [Invoke API](/docs/api/invoke) instead.

## Rate Limiting

Rate limits apply the same as the Invoke API:
- **Free**: Lower limits for basic usage
- **Pro**: Higher limits for regular usage  
- **Enterprise**: Custom limits

Rate limit details are not currently exposed in response headers.

## Token Usage

<Callout type="note">
**Token Counting** - Token counts in the `done` event are approximated using `length / 4` and may not reflect actual LLM provider token usage.
</Callout>

Token usage is reported in the final `done` event, allowing you to track costs and usage patterns for streaming requests.

## SDKs and Examples

- **[JavaScript/TypeScript Examples](/docs/examples/javascript)**
- **[Python Examples](/docs/examples/python)**  
- **[cURL Examples](/docs/examples/curl)**